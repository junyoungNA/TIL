<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        
        // class Person {
        //     constructor() {
        //         this.name='name'
        //     }
        //     hi() {
        //         console.log('hi');
        //     }
        // }
        // const foo = new Person();
        // console.dir(foo);
        // console.dir(Person);
        // //__proto__ 를 이용해 자식 객체의 prototype의 접근가능
        // //생성자 함수는 prototype을 이용
        // console.log(foo.__proto__ === Person.prototype);


        // function Person() {
        //     this.name = 'name'
        //     this.say = function () {
        //         console.log(this.name);
        //     }
        // }

        //     Person.prototype.hi = () => console.log('hi person')
        //     Person.prototype.bye = () => console.log('bye person')
        //     Person.prototype.someValue = 'something wrong...'
        //     Person.prototype.hi();
            //프로토 타입 생성자함수의 직접 접근할 없음!
            //하지만 간접적으로는 접근가능 자식 객체를 통해등등
            //265페이지!
            // console.log(Person.prototype.say());
            // const foo = new Person();   
            // const bar = new Person();
            // bar.hi()
            // foo.hi()
            // console.dir(foo);
            // console.dir(Person);
            // console.log(foo.__proto__ === Person.prototype);
            //프로토타입과 생성자 함수는 단독으로 존재할수 없고
            //항상 쌍으로 존재한다.

            //Object는 Number() 와 String() 처럼 자바스크립트에서 만든 빌트인객체?
            // const obj = {}
            // //모든 객체는 빌트인 객체Object의 자식이다?
            // console.log(obj.constructor === Object);
            const obj = new Object();
            // obj.x = 1;
            //Object 생성자 함수에 의해 생성된 Obj 객체는 Object.prototype을 상속받는다.
            // console.log(obj.constructor === Object);
            // //함수 리터럴
            // // const add = new Function('a', 'b', 'return a + b');
            // const add = function (a, b) {return a + b};

            // //배열 리터럴
            // // const arr = new Array(1,2,3);
            // const arr = [1, 2, 3];

            //288페이지
            //자바스크립트는 객체의 프로퍼티에 접근하려고 할때 해당 객체에 접근하려는 프로퍼티가 없다면
            //내부 슬롯의 참조를 따라 자신의 부모 역할을 하는 프로토타입의 프로퍼티를 순차적으로
            //검색한다. 이를 프로토타입 체인이라 하며 프로토타입 체인은 자바스크립트가
            //객체지향 프로그래밍의 상속을 구현하는 매커니즘이다.
            // me = {name:'zoon'};
            // console.log(me.hasOwnProperty('name'));

            //이처럼 스코프 체인과 프로토타입 체인은 서로 연관없이 동작하는 것이 아니라 서로 협력하여
            // 식별자와 프로퍼티를 검색한다.


            const Person = (function () {
                //생성자 함수
                function Person(name) {
                    this.name= name
                }

                //프로토타입 메서드
                Person.prototype.sayHello = function () {
                    console.log(`안녕하세요! 저는${this.name}`);
                }

                //생성자 함수 반환
                return Person;
            }());

            const me = new Person('zoon');
               //인스턴스 메서드
            me.sayHello = function () {
                console.log(`hello this is ${this.name}`)
            }
            me.sayHello();

                //hello this is  zoon

            // let name = 'ZOON'

            // function changeName () {
            //     name = '준영';
            //     console.log(name);
            // }
            // changeName();

            //오버라이딩이란 상위 클래스가 가지고 있는 메서드를 하위 클래스가 재정의하여 사용하는 방식!
            //상속관계에 의해 프로퍼티가 가려지는 현상을 프로퍼티 새도잉 이라고 부름
            //오버로딩이란 함수의 이름을 동일하지만 매개변수의 타입 또는 개수가 다른 메서드를 구현하고
            //매개변수에 의해 메서드를 구별하여 호출하는 방식이다. 
    </script>
    
</body>
</html>